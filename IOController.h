#include "systemc.h"

SC_MODULE(IO_Controller) {
    // Входные порты
    sc_in<bool> clk; // Тактовый сигнал
    sc_in<bool> data_ready; // Флаг готовности данных на внешнем накопителе
    sc_in<bool> result_ready; // Флаг готовности результата вычисления НС
    sc_in<bool> interrupt_signal; // Сигнал прерывания от вычислительных ядер

    // Выходные порты
    sc_out<bool> load_data; // Сигнал загрузки данных из внешнего накопителя в общую память
    sc_out<bool> unload_data; // Сигнал выгрузки данных из общей памяти на вычислительное ядро
    sc_out<int> target_address; // Адрес, куда нужно передать данные для вычислений
    sc_out<int> result_address; // Адрес, куда нужно поместить результат вычислений
    sc_out<int> layer_number; // Номер текущего обрабатываемого слоя
    sc_out<bool> unload_result; // Сигнал выгрузки результата вычисления НС на выходной порт

    // Внутренние переменные
    int current_layer = 0; // Текущий обрабатываемый слой
    bool is_busy = false; // Флаг занятости вычислительных ядер

    // Процессор, отвечающий за управление устройством
    void control_process() {
        while (true) {
            wait(); // Ожидание следующего такта

            // Если есть сигнал прерывания, то сохраняем текущий слой и адрес, куда нужно было передать данные
            if (interrupt_signal.read()) {
                current_layer++; // Переходим к следующему слою
                target_address.write(result_address.read()); // Передаем данные на вычисление в предыдущее вычислительное ядро
                layer_number.write(current_layer); // Сохраняем номер текущего слоя
            }

            // Если есть готовые данные на внешнем накопителе, то загружаем их в общую память
            if (data_ready.read()) {
                load_data.write(true); // Посылаем сигнал на загрузку данных
            }

            // Если есть свободные вычислительные ядра и есть данные для передачи, то передаем данные на вычисление
            if (!is_busy && unload_data.read()) {
                target_address.write(target_address.read() + 1); // Переходим к следующему нейрону в текущем слое
                result_address.write(result_address.read() + 1); // Переходим к следующему свободному адресу для записи результата
                unload_data.write(false);
                is_busy = true; // Устанавливаем флаг занятости вычислительных ядер
            }

            // Если есть готовый результат вычисления, то выгружаем его на выходной порт НС
            if (result_ready.read()) {
                unload_result.write(true); // Посылаем сигнал на выгрузку результата
                is_busy = false; // Снимаем флаг занятости вычислительных ядер
            }
        }
    }

    // Конструктор модуля
    SC_CTOR(IO_Controller) {
        // Запускаем процессор, отвечающий за управление устройством
        SC_THREAD(control_process);
        sensitive << clk.pos(); // Привязываем процесс к положительному фронту тактового сигнала
    }
};